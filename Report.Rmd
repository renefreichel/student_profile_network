---
title: "Report"
author: "Wessley Kameraad, Ren√© Freichel, Jan Simson"
date: "18.01.2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo = FALSE, message = FALSE, warning = FALSE}
installed_packages <- installed.packages()[, "Package"]

## Install Missing Required Packages
if (!"tidyverse" %in% installed_packages) {
  install.packages("tidyverse")
  }
if (!"qgraph" %in% installed_packages) {
  install.packages("qgraph")
}
if (!"dplyr" %in% installed_packages) {
  install.packages("dplyr")
}
if (!"psych" %in% installed_packages) {
  install.packages("magrittr")
}
if (!"bootnet" %in% installed_packages) {
  install.packages("bootnet")
}
if (!"mgm" %in% installed_packages) {
  install.packages("mgm")
}
if (!"janitor" %in% installed_packages) {
  install.packages("janitor")
}
if (!requireNamespace("BiocManager", quietly = TRUE)){
  install.packages("BiocManager")
  BiocManager::install("Rgraphviz")
}
    

## Load packages
library("tidyverse")
library("qgraph")
library("dplyr")
library("magrittr")
library("bootnet")
library("mgm")
library("janitor")
library("bnlearn")
library("Rgraphviz")
```

```{r load_raw_data, message=FALSE, warning=FALSE}
cohorts <- c("1718", "1819", "1920")

# Load and combine the three CSVs
raw_data <- data.frame()
for (cohort in cohorts) {
  file <- paste0("data/anonymized_cohort", cohort, ".csv")
  
  cohort_data <- read_csv2(file) %>%
    clean_names() %>% 
    mutate(
      # Add a new column "cohort"
      cohort = cohort
    )

  
  # Add new cohorts data to joined data frame
  raw_data <- bind_rows(
    raw_data,
    cohort_data
  )
}
```

```{r tidy_data}
# Create a tidy dataframe with a subset of the data
full_tidy_data <- raw_data %>% 
  transmute(
    # Parse the grade as a decimal number
    grade = parse_number(
      offic_cijfer,
      locale = locale(decimal_mark = ",", grouping_mark = ".")
    ) %>%
      suppressWarnings,
    # Put all special grades (i.e. letters) into a separate column
    grade_special = if_else(is.na(grade), offic_cijfer, as.character(NA)),
    # Rename & select other columns
    specialisation = specialisatie,
    course_id = studiegids,
    student_id = masked_id,
    # The short description has different column names in different cohorts
    short_description = if_else(is.na(omschr_10), omschr_11, omschr_10),
    long_description = curs_omschr_l,
    cohort = cohort,
    rank = rangnummer,
    country = land
  )
```

```{r filter_data}
selected_courses <- c(
  "7201602PXY", # 1. Introduction Psychology & Cognition
  "7201604PXY", # 2. Research Methods & Statistics
  "7201605PXY", # 3. Developmental Psy
  "7201607PXY", # 4. Social & Work Psy
  "7201622PXY" # 5. Clinical Psychology & Brain
  # 5. is matched with "7201610PXY": Clinical & Biological Psy (1718)
)

# Merge the two courses across cohorts:
# Clinical Psychology & Brain (cohorts 1819, 1920)
# Clinical & Biological Psy (cohort 1718)
# and remove any instances where a student has taken both courses
# (that means they failed the first one, so that is dropped)
students_with_double_bio_courses <- full_tidy_data %>%
  filter(course_id %in% c("7201622PXY", "7201610PXY")) %>% 
  count(student_id) %>% 
  filter(n > 1) %>% 
  pull(student_id)
full_tidy_data <- full_tidy_data %>%
  filter(
    # Only keep the newer bio course if a student has both
    # (this means they failed to complete the old bio course)
    course_id != "7201610PXY" | !(student_id %in% students_with_double_bio_courses)
  ) %>% 
  mutate(
    course_id = if_else(course_id == "7201610PXY", "7201622PXY", course_id),
    short_description = if_else(
      course_id == "7201622PXY",
      "Clinical Psychology & Brain / Bio",
      short_description
    ),
    long_description = if_else(
      course_id == "7201622PXY", 
      "[Combined] Clinical Psychology & Brain + Clinical & Biological Psy", 
      long_description
    )
  )

data <- full_tidy_data %>%
  # Only include students who picked a specialisation
  filter(!is.na(specialisation) & specialisation != "0") %>% 
  filter(specialisation != "Algemene Psychologie") %>% 
  # Include only first year courses
  filter(course_id %in% selected_courses)
```

```{r}
data_wide <- data %>%
  select(specialisation, grade, course_id, student_id) %>%
    group_by(student_id) %>%
      pivot_wider(.,
                  names_from = course_id,
                  values_from = grade) %>%
          ungroup()
data_wide
```

```{r}
# Assigning uniform column names for the courses
colnames(data_wide) <-
  c("Specialization",
    "ID",
    "IPC",              #7201602PXY
    "RMS",              #7201604PXY
    "DEV",              #7201605PXY
    "SWO",              #7201607PXY
    "CB")               #7201610PXY
```

```{r}
data_wide %>%
  distinct(ID, Specialization) %>%
    count(Specialization)
```
***

## Mixed Graphical Models

```{r mgm_setup}
library(mgm)

generate_wide_grades <- function (data, grade_column) {
  data %>%
    pivot_wider(
      id_cols = student_id,
      names_from = short_description,
      
      # Use variable to assign grade column
      values_from = grade_column
    ) %>% 
    # Add a column with specialisation info
    left_join(
      data %>%
        select(student_id, specialisation) %>%
        distinct(),
      by = "student_id"
    )
}

# Collect some info about columns
# This just needs to be a list of characters for each column indicating
# the type. Automated code here is just for flexibility.
extract_mgm_column_info <- . %>% 
  # Get only TRUE/FALSE whether columns are numeric
  summarise(across(everything(), is.numeric)) %>% 
  # Get into long format with column names and whether they are numeric in 2 columns
  pivot_longer(
    everything(),
    names_to = "column",
    values_to = "is_numeric"
  ) %>% 
  # Assign letters based on whether column is numeric or not
  mutate(
    # Types for mgm
    # g: gaussian (normal dist.)
    # c: categorical
    # p: poisson (if skewed)
    type = ifelse(is_numeric, "g", "c")
  )
```

### Initial Mixed Graphical Model

Fit a mgm using gaussian distributions for grade data, this has approach is more interpretable, but has a much lower N due to NAs in the data which have to be dropped per row.
```{r mgm_numerical}
# ==== Preparate data for MGM ====
mgm_num_data <- data %>% 
  generate_wide_grades("grade") %>%
  # Drop Student IDs
  select(-student_id) %>% 
  # Drop all NAs (NOTE: this loses us about 2/3 of the data)
  na.omit()

column_info <- extract_mgm_column_info(mgm_num_data)

# Transform categorical variables to integers
# mgm wants all data as numbers!
mgm_num_data_numeric <- mgm_num_data %>% 
  mutate(
    specialisation = as.numeric(as.factor(specialisation))
  )

# V1: mgm package directly
fit_mgm_num <- mgm(
  data = mgm_num_data_numeric,
  type = column_info$type
)
qgraph::qgraph(
  fit_mgm_num$pairwise$wadj,
  nodeNames = column_info$column,
  theme = "colorblind",
  layout = "spring"
)

# Create a factor graph (whatever that is?)
# Also shows interaction effects as squares
FactorGraph(fit_mgm_num)

# Predict the training data
prediction_mgm <- predict(fit_mgm_num, data = mgm_num_data_numeric)
prediction_mgm$errors # Prediction error
prediction_mgm$predicted %>% head()
```

### Predict the 1920 cohort using the numerical mgm.

> Note: we might want to drop this part because currently predictions are all category 5: clinical.

```{r mgm_num_predict_1920}
new_mgm_num_data <- full_tidy_data %>% 
  filter(cohort == 1920) %>% 
  # Include only first year courses
  filter(course_id %in% selected_courses) %>% 
  generate_wide_grades("grade") %>% 
  select(-student_id) %>% 
  # Just put in random numbers for specialisation
  mutate(specialisation = sample(1:7, nrow(.), replace = T)) %>% 
  na.omit()

new_prediction_mgm <- predict(fit_mgm_num, data = new_mgm_num_data)
new_prediction_mgm$predicted %>% head(20)
```

***

## Initial Feature Options

### Estimating Features for Prediction 

```{r}
dataFeatures <- data_wide

dataFeatures %<>%  
    select(IPC, RMS,DEV,SWO,CB) %>%
      data.frame(., # Original data,
                 scaleCourse = scale(., scale = FALSE), # Subtract column mean from observation for all courses
                 #scalePers = scale(., scale = TRUE), # Normalize grades per person
                 GPA = apply(., 1, mean), # GPA
                 sd = apply(., 1, sd), # Standard Deviation Grades
                 range = apply(., 1, function(x) max(x) - min(x)), # Difference between max and min
                 fails = apply(., 1, function(x) sum(is.na(x)))) # Number of courses failed
                 

dataFeatures
```

```{r}
networkFeatures <- 
  dataFeatures %>%
  select(-fails, -c(IPC, RMS,DEV,SWO,CB)) %>% 
  estimateNetwork(na.omit(.),
                  stepwise = TRUE,
                  default = "ggmModSelect",
                  corMethod = "cor_auto")

qgraph(networkFeatures$graph)
```

### Trichotomised Split 

Here we bin the data according to grade:

* < 6 = 1; These are the NAs, which imply failed grades
* 6 - 7 = 2
* > 7 = 3

```{r}
dataOrdinal <- data_wide
dataOrdinal[is.na(dataOrdinal)] <- 0

dataOrdinal %<>%
    select("IPC", "RMS", "DEV","SWO", "CB") %>% 
    lapply(., function(x){ifelse(x < 6, 1,
                                 ifelse(x > 7, 3, 2))}) %>%
        as.data.frame()

networkOrdinal <- estimateNetwork(dataOrdinal,
                                   default = "pcor",
                                   corMethod = "cor_auto")

qgraph(networkOrdinal$graph)
```

---------------------------------------------------------------------------------------------------------------

### Bayesian Network

```{r}
set.seed(111)
dataBN <- na.omit(data_wide[,-c(1, 2)])
estBN <- hc(dataBN,
            restart = 10,
            perturb = 100)

estBN
```

```{r}
(edgeStrength <- arc.strength(estBN, dataBN, "bic-g"))
```

```{r}
strength.plot(estBN,
              edgeStrength,
              main = "Bayesian Network",
              shape = "ellipse")
```

```{r}
set.seed(333)
bootBN <- boot.strength(dataBN,
                        R = 2000,
                        algorithm = "hc")
```

```{r}
averageBN <- averaged.network(bootBN,
                              threshold = .95) # Edges appear in 95% of estimated networks

edgeStrengthAvg <- arc.strength(averageBN,
                                dataBN,
                                "bic-g")

strength.plot(averageBN,
              edgeStrengthAvg,
              main = "Bootstrapped Bayesian",
              shape = "ellipse")
```

```{r}
subEdge <- bootBN[bootBN$strength > 0.95,]
subEdge
```

```{r}
bootTab <- bootBN[bootBN$strength > 0.85 &
                    bootBN$direction > 0.5,]
avgStr <- bootTab
avgStr$strength <- bootTab$direction

strength.plot(averageBN,
              avgStr,
              main = "Averaged Bayesian Network",
              shape = "ellipse")
```

---------------------------------------------------------------------------------------------------------------
### Full Information Maximum Likelihood Estimation

```{r}
# Create column for number of NAs in row
dataImpute <- data_wide
dataImpute$NAs <- apply(dataImpute, 1, function(x){sum(is.na(x))})
```

```{r}
# Full Information Max Likelihood for Cases with one (1) missing value
networkImputeNA1 <- 
  # Retain rows with one or less missing value
  dataImpute[dataImpute$NAs < 2,] %>% 
    # Only retain the course grade columns
    select(c("IPC", "RMS", "DEV","SWO", "CB")) %>%  
      estimateNetwork(.,
                      default = "EBICglasso",
                      corMethod = "cor_auto",
                      missing = "fiml")
# Estimate graph
qgraph(networkImputeNA1$graph,
       layout = "spring",
       theme = "colorblind")
```
```{r}
# Full Information Max Likelihood for Cases with two (2) or less missing values
networkImputeNA2 <- 
  # Retain rows with two or less missing values
  dataImpute[dataImpute$NAs < 2,] %>% 
    # Only retain the course grade columns
    select("IPC", "RMS", "DEV","SWO", "CB") %>%  
      estimateNetwork(.,
                      default = "EBICglasso",
                      corMethod = "cor_auto",
                      missing = "fiml")
# Estimate graph
qgraph(networkImputeNA2$graph,
       layout = "spring",
       theme = "colorblind")
```

```{r}
# Estimate a correlation matrix after imputing all missing values using FIML
psych::corFiml(data_wide[,-c(1, 2)])

# Estimate a network structure using partial correlations from imputed correlation matrix
estimateFIML <- 
  estimateNetwork(psych::corFiml(data_wide[,-c(1, 2)]),
                  default = "pcor",
                  corMethod = "spearman")


qgraph(psych::corFiml(dataImpute[,-c(1, 2, 8)]))
qgraph(estimateFIML$graph)
```